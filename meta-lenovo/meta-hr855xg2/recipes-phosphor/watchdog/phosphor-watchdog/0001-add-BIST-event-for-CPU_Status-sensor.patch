--- a/watchdog.cpp	2019-08-01 10:32:02.450108273 +0800
+++ b/watchdog.cpp	2019-08-01 11:03:01.731201659 +0800
@@ -17,12 +17,66 @@
 
 using sdbusplus::exception::SdBusError;
 using sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure;
+using Value = std::variant<bool, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
+                           int64_t, uint64_t, double, std::string>;
 
 // systemd service to kick start a target.
 constexpr auto SYSTEMD_SERVICE = "org.freedesktop.systemd1";
 constexpr auto SYSTEMD_ROOT = "/org/freedesktop/systemd1";
 constexpr auto SYSTEMD_INTERFACE = "org.freedesktop.systemd1.Manager";
 
+constexpr auto PROP_INTF = "org.freedesktop.DBus.Properties";
+constexpr auto CPUSensorService = "xyz.openbmc_project.CPUSensor";
+constexpr auto CPUSensorPath = "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+constexpr auto CPUSensorIntf = "xyz.openbmc_project.Inventory.Item.Cpu";
+constexpr auto CPUSensorPresentIntf = "xyz.openbmc_project.Inventory.Item";
+constexpr auto IPMIService = "xyz.openbmc_project.Ipmi.Host";
+constexpr auto IPMIPath = "/xyz/openbmc_project/Ipmi";
+constexpr auto IPMIIntf = "xyz.openbmc_project.Ipmi.Server";
+
+uint8_t add_sel_event(sdbusplus::bus::bus& bus, uint8_t snr_num, uint8_t snr_type,
+                      uint8_t ed1, uint8_t ed2, uint8_t ed3) 
+{
+    uint8_t netFn = 0x0A; // Storage
+    uint8_t lun = 0x00;
+    uint8_t cmd = 0x44; // Add SEL Entry command
+    std::vector<uint8_t> data = { 0x00, 0x00,             // Record ID
+                                  0x02,                   // Record Type
+                                  0x00, 0x00, 0x00, 0x00, // Time Stamp
+                                  0x20, 0x00,             // Generator ID
+                                  0x04,                   // EvM Rev
+                                  snr_type,               // Sensor Type
+                                  snr_num,                // Sensor #
+                                  0x6F,                   // Event Dir | Event Type
+                                  ed1,                    // Event Data 1
+                                  ed2,                    // Event Data 2
+                                  ed3};                   // Event Data 3
+    std::map<std::string, sdbusplus::message::variant<int>> options;
+    // Watchdog Expired
+    try
+    {
+        Value value;
+        auto add_sel = bus.new_method_call(IPMIService, IPMIPath, IPMIIntf, "execute");
+        add_sel.append(netFn, lun, cmd, data, options);
+        auto reply = bus.call(add_sel);
+
+        if (reply.is_method_error())
+        {
+            fprintf(stderr, "Failed to add sel by method error\n");
+            //log<level::ERR>("Failed to add sel by method error");
+            return 1;
+        }
+    }
+    catch (const SdBusError& e)
+    {
+        fprintf(stderr, "Failed to add sel %s\n", e.what());
+        //log<level::ERR>("watchdog: Failed to add sel");
+        return 1;
+    }
+
+    return 0;
+}
+
 void Watchdog::resetTimeRemaining(bool enableWatchdog)
 {
     timeRemaining(interval());
@@ -110,6 +164,53 @@
 
     expiredTimerUse(currentTimerUse());
 
+    if (convertForMessage(expiredTimerUse()) == "xyz.openbmc_project.State.Watchdog.TimerUse.OSLoad") { 
+        // There are MAX 4 CPU on HR855XG2
+        for (auto index=0; index<4; index++)
+        {
+            Value value;
+            const auto name = "CPU" + std::to_string(index) + "_Status";
+
+            try
+            {
+                auto method = bus.new_method_call(CPUSensorService, (CPUSensorPath + name).c_str(),
+                                                  PROP_INTF, "Get");
+                method.append(CPUSensorPresentIntf, "Present");
+                auto reply = bus.call(method);
+
+                if (reply.is_method_error())
+                {
+                    log<level::ERR>("Failed to get property");
+                }
+
+                reply.read(value);
+                // If CPU is not present, we don`t need to modify the BIST failure status for corresponding sensor
+                if (!std::get<bool>(value))
+                    continue;
+                
+                sdbusplus::message::variant<bool> BIST_state = true;
+                method = bus.new_method_call(CPUSensorService, (CPUSensorPath + name).c_str(),
+                                             PROP_INTF, "Set");
+                method.append(CPUSensorIntf, "BIST_failure", BIST_state);
+                if (!bus.call(method))
+                {
+                    log<level::ERR>("Failed to set property BIST_failure");
+                }
+
+                uint8_t ret = add_sel_event(bus, (0x91 + index), 0x07, 0x02, 0xFF, 0xFF);
+                if (0 != ret) 
+                {
+                    fprintf(stderr, "Failed to add sel event\n");
+                    //log<level::ERR>("Failed to add sel event");
+                }
+            }
+            catch (const SdBusError& e)
+            {
+                log<level::ERR>("watchdog: Failed to set BIST Failure");
+            }
+        }
+    }
+
     auto target = actionTargetMap.find(action);
     if (target == actionTargetMap.end())
     {
