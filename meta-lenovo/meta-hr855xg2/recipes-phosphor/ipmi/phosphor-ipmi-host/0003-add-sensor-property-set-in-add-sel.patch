--- a/storagehandler.cpp	2019-09-09 14:17:45.197680338 +0800
+++ b/storagehandler.cpp	2019-09-10 14:17:41.993242404 +0800
@@ -59,6 +59,16 @@
 using namespace phosphor::logging;
 using namespace ipmi::fru;
 
+static constexpr auto InventoryService = "xyz.openbmc_project.Inventory.Manager";
+static constexpr auto InventoryPath = "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+static constexpr auto InventoryECCIntf = "xyz.openbmc_project.Memory.MemoryECC";
+static constexpr auto CPUSensorService = "xyz.openbmc_project.CPUSensor";
+static constexpr auto CPUSensorPath = "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+static constexpr auto CPUSensorIntf ="xyz.openbmc_project.Inventory.Item.Cpu";
+static constexpr auto OEMSensorService = "xyz.openbmc_project.OEMSensor";
+static constexpr auto OEMSensorPath = "/xyz/openbmc_project/OEMSensor/";
+static constexpr auto OEMSensorIntf = "xyz.openbmc_project.Sensor.Discrete.SpecificOffset";
+
 /**
  * @enum Device access mode
  */
@@ -581,6 +591,217 @@
     return rc;
 }
 
+// Lenovo Set Sensor Property
+uint8_t LenovoSetSensorProperty(uint8_t sensorNumber,
+                                std::array<uint8_t, eventDataSize> eventData)
+{
+    sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+    std::string event_state;
+    std::string PropertyPath;
+    if (sensorNumber >= 0xA0 && sensorNumber <= 0xCF)
+    {
+        char index[] = { 'A', 'B', 'C', 'D', 'E', 'F' };
+        const auto name = "CPU" + std::to_string((sensorNumber - 0xA0)/12) +
+                          "_DIMM" + index[((sensorNumber - 0xA0)%12)/2] +
+                          std::to_string((sensorNumber - 0xA0)%2 + 1);
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x00:
+                    event_state = "xyz.openbmc_project.Memory.MemoryECC.ECCStatus.CE";
+                    PropertyPath = "state";
+                    ipmi::setDbusProperty(bus, InventoryService,
+                                          InventoryPath + name, InventoryECCIntf,
+                                          PropertyPath, event_state);
+                    break;
+                case 0x01:
+                    event_state = "xyz.openbmc_project.Memory.MemoryECC.ECCStatus.UE";
+                    PropertyPath = "state";
+                    ipmi::setDbusProperty(bus, InventoryService,
+                                          InventoryPath + name, InventoryECCIntf,
+                                          PropertyPath, event_state);
+                    break;
+                case 0x05:
+                    PropertyPath = "isLoggingLimitReached";
+                    ipmi::setDbusProperty(bus, InventoryService,
+                                          InventoryPath + name, InventoryECCIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+    else if (sensorNumber >= 0x91 && sensorNumber <= 0x94)
+    {
+        const auto name = "CPU" + std::to_string(sensorNumber - 0x91) + "_Status";
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x05:
+                    PropertyPath = "Configuration_Error";
+                    ipmi::setDbusProperty(bus, CPUSensorService,
+                                          CPUSensorPath + name, CPUSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+    else if (sensorNumber >= 0xD0 && sensorNumber <= 0xDB)
+    {
+        const auto name = "PE" + std::to_string((sensorNumber - 0xD0)/5 + 1) + 
+                          "S" + std::to_string((sensorNumber - 0xD0)%5 + 1) + 
+                          "_Bus_Status";
+
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x04:
+                    PropertyPath = "Offset_4";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x05:
+                    PropertyPath = "Offset_5";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x07:
+                    PropertyPath = "Offset_7";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x08:
+                    PropertyPath = "Offset_8";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x0A:
+                    PropertyPath = "Offset_10";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x0B:
+                    PropertyPath = "Offset_11";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                case 0x0F:
+                    PropertyPath = "Offset_15";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+    else if (sensorNumber == 0xF9)
+    {
+        std::string name = "UPI_Error";
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x05:
+                    PropertyPath = "Offset_5";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+    else if (sensorNumber == 0xFC)
+    {
+        std::string name = "NVRAM_Corrupt";
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x00:
+                    PropertyPath = "Offset_0";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+    else if (sensorNumber == 0xFD)
+    {
+        std::string name = "CPU_Exception";
+        try
+        {
+            switch (eventData[0])
+            {
+                case 0x01:
+                    PropertyPath = "Offset_1";
+                    ipmi::setDbusProperty(bus, OEMSensorService,
+                                          OEMSensorPath + name, OEMSensorIntf,
+                                          PropertyPath, true);
+                    break;
+                default:
+                    return 1;
+                    break;
+            }
+        }
+        catch (std::exception& e)
+        {
+            log<level::ERR>(e.what());
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
 /** @brief implements the Add SEL entry command
  * @request
  *
@@ -614,6 +835,12 @@
         return ipmi::responseUnspecifiedError();
     }
 
+    uint8_t ret = LenovoSetSensorProperty(sensorNumber, eventData);
+    if (0 != ret)
+    {
+        std::cerr << "Set Property Failed" << "\n";
+    }
+
     return ipmi::responseSuccess(recordID);
 }
 
