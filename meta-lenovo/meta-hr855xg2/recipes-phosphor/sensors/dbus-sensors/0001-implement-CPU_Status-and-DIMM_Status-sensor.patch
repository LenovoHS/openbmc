--- a/src/CPUSensorMain.cpp	2019-08-07 12:49:27.458617470 +0800
+++ b/src/CPUSensorMain.cpp	2019-08-08 01:23:05.602816765 +0800
@@ -79,6 +79,57 @@
 static constexpr std::array<const char*, 3> hiddenProps = {
     CPUSensor::labelTcontrol, "Tthrottle", "Tjmax"};
 
+constexpr auto fpgaService = "org.openbmc.control.fpga";
+constexpr auto fpgaRoot = "/org/openbmc/control/fpga";
+constexpr auto fpgaInterface = "org.openbmc.control.fpga";
+constexpr auto InventoryService = "xyz.openbmc_project.Inventory.Manager";
+constexpr auto InventoryPath = "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+constexpr auto InventoryItemIntf = "xyz.openbmc_project.Inventory.Item";
+constexpr auto PROP_INTF = "org.freedesktop.DBus.Properties";
+constexpr auto IPMIService = "xyz.openbmc_project.Ipmi.Host";
+constexpr auto IPMIPath = "/xyz/openbmc_project/Ipmi";
+constexpr auto IPMIIntf = "xyz.openbmc_project.Ipmi.Server";
+
+uint8_t add_sel_event(const std::shared_ptr<sdbusplus::asio::connection>& bus, uint8_t snr_num, uint8_t snr_type,
+                      uint8_t ed1, uint8_t ed2, uint8_t ed3) 
+{
+    uint8_t netFn = 0x0A; // Storage
+    uint8_t lun = 0x00;
+    uint8_t cmd = 0x44; // Add SEL Entry command
+    std::vector<uint8_t> data = { 0x00, 0x00,             // Record ID
+                                  0x02,                   // Record Type
+                                  0x00, 0x00, 0x00, 0x00, // Time Stamp
+                                  0x20, 0x00,             // Generator ID
+                                  0x04,                   // EvM Rev
+                                  snr_type,               // Sensor Type
+                                  snr_num,                // Sensor #
+                                  0x6F,                   // Event Dir | Event Type
+                                  ed1,                    // Event Data 1
+                                  ed2,                    // Event Data 2
+                                  ed3};                   // Event Data 3
+    std::map<std::string, sdbusplus::message::variant<int>> options;
+    try
+    {
+        auto add_sel = bus->new_method_call(IPMIService, IPMIPath, IPMIIntf, "execute");
+       add_sel.append(netFn, lun, cmd, data, options);
+        auto reply = bus->call(add_sel);
+
+        if (reply.is_method_error())
+        {
+            fprintf(stderr, "Failed to add sel by method error\n");
+            //log<level::ERR>("Failed to add sel by method error");
+            return 1;
+        }
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        std::cerr << "Failed to add sel %s\n" << e.what();
+        return 1;
+    }
+
+    return 0;
+}
+
 void detectCpuAsync(
     boost::asio::deadline_timer& pingTimer,
     boost::asio::deadline_timer& creationTimer, boost::asio::io_service& io,
@@ -549,6 +600,7 @@
         {
             return false;
         }
+
         useCache = true;
     }
 
@@ -584,6 +636,59 @@
                     {
                         present = cpuIsPresent(suppConfig.second);
                         break;
+                    } else if (suppConfig.first.find("PresenceByFPGA") !=
+                               std::string::npos)
+                    {
+                        auto fpgaConfig = suppConfig.second;
+                        uint8_t res_data = 0xFF;
+                        uint8_t cpu_num = std::stoi(name.substr(3,1));
+
+                        auto findFpgaBlock = fpgaConfig.find("FpgaBlock");
+                        auto findFpgaBit = fpgaConfig.find("FpgaBit");
+                        auto findFpgaAddr = fpgaConfig.find("FpgaAddr");
+
+                        if (findFpgaBlock == fpgaConfig.end() ||
+                            findFpgaBit == fpgaConfig.end() ||
+                            findFpgaAddr == fpgaConfig.end())
+                        {
+                            std::cerr << "Incorrect FPGA configuration\n";
+                            break;
+                        }
+
+                        uint64_t FpgaBlock =
+                            std::visit(VariantToUnsignedIntVisitor(), findFpgaBlock->second);
+                        uint64_t FpgaBit =
+                            std::visit(VariantToUnsignedIntVisitor(), findFpgaBit->second);
+                        uint64_t FpgaAddr =
+                            std::visit(VariantToUnsignedIntVisitor(), findFpgaAddr->second);
+
+                        auto method = systemBus->new_method_call(fpgaService, fpgaRoot,
+                                                                 fpgaInterface, "read_fpga");
+
+                        method.append((uint8_t) FpgaBlock, (uint8_t) FpgaAddr);
+                        try
+                        {
+                            auto pid = systemBus->call(method);
+                            if (pid.is_method_error())
+                            {
+                                 std::cerr << "Error in method call\n";
+                            }
+                        
+                            pid.read(res_data);
+                        }
+                        catch (const sdbusplus::exception::SdBusError& e)
+                        {
+                            std::cerr << "fpga dbus error\n";
+                        }
+                        
+                        present = (~res_data >> (uint8_t)FpgaBit) & 0x01;
+                        if (present) {
+                            uint8_t ret = add_sel_event(systemBus, (0x91 + cpu_num), 0x07, 0x07, 0xFF, 0xFF);
+                            if (0 != ret) 
+                            {
+                                fprintf(stderr, "Failed to add sel event\n");
+                            }
+                        }
                     }
                 }
 
@@ -595,6 +700,16 @@
                     iface->register_property("PrettyName", name);
                     iface->register_property("Present", present);
                     iface->initialize();
+                    iface = objectServer.add_interface(
+                            cpuInventoryPath + std::string("/") + name,
+                            "xyz.openbmc_project.Inventory.Item.Cpu");
+                    iface->register_property("Thermal_Trip", false,
+                                             sdbusplus::asio::PropertyPermission::readWrite);
+                    iface->register_property("BIST_failure", false,
+                                             sdbusplus::asio::PropertyPermission::readWrite);
+                    iface->register_property("Configuration_Error", false,
+                                             sdbusplus::asio::PropertyPermission::readWrite);
+                    iface->initialize();
                     inventoryIfaces[name] = std::move(iface);
                 }
                 if (!present)
@@ -634,6 +749,69 @@
         }
     }
 
+    // DIMM Present by CPLD
+    // No reason to look for DIMM present for non present cpu
+    uint64_t dimm_present = 0;
+    for (uint8_t dimm_offset=6; dimm_offset<12; dimm_offset++)
+    {
+        uint8_t DIMM_FpgaBlock = 10;
+        uint8_t res_data = 0x00;
+        auto method = systemBus->new_method_call(fpgaService, fpgaRoot,
+                                                 fpgaInterface, "read_fpga");
+        method.append(DIMM_FpgaBlock, dimm_offset);
+        try
+        {
+            auto pid = systemBus->call(method);
+            if (pid.is_method_error())
+            {
+                std::cerr << "Error in method call\n";
+            }
+            pid.read(res_data);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::cerr << "fpga dbus error\n";
+        }
+
+        dimm_present |= ((uint64_t) res_data) << ((dimm_offset-6)*8);
+    }
+
+    fprintf(stderr, "dimm_present: %x\n", dimm_present);
+    std::string index[] = { "C1", "C2", "B1", "B2", "A1", "A2", "D2", "D1", "E2", "E1", "F2", "F1" };
+    uint8_t dimm_loc[] = { 4, 5, 2, 3, 0, 1, 7, 6, 9, 8, 11, 10 };
+    for (uint64_t dimm_num=0; dimm_num<48; dimm_num++)
+    {
+        sdbusplus::message::variant<bool> dpresent = false;
+        if (0 != ((dimm_present & (1 << dimm_num))))
+        {
+            // Add SEL
+            uint8_t ret = add_sel_event(systemBus, (0xA0 + 12*(dimm_num/12) + dimm_loc[dimm_num%12]), 0x0C, 0x06, 0xFF, 0xFF);
+            if (0 != ret)
+            {
+                std::cerr << "Failed to add sel event\n";
+            }
+            dpresent = true;
+        }
+
+        // Set Discrete sesnsor
+        const auto dimm_name = "CPU" + std::to_string(dimm_num/12) +
+                               "_DIMM_" + index[((dimm_num)%12)];
+        try
+        {
+            auto method = systemBus->new_method_call(InventoryService, (InventoryPath + dimm_name).c_str(),
+                                                     PROP_INTF, "Set");
+            method.append(InventoryItemIntf, "Present", dpresent);
+            if (!systemBus->call(method))
+            {
+                std::cerr << "Failed to set property DIMM presence" << "\n";
+            }
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::cerr << e.what() << "\n";
+        }
+    }
+
     if (cpuConfigs.size())
     {
         std::cout << "CPU config" << (cpuConfigs.size() == 1 ? " is" : "s are")
