diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2019-08-07 12:49:27.438617235 +0800
+++ b/CMakeLists.txt	2019-08-21 17:29:37.599481259 +0800
@@ -37,7 +37,8 @@
 option (HUNTER_ENABLED "Enable hunter package pulling" OFF)
 
 option (DISABLE_ADC "Disable installing ADC sensor" OFF)
-option (DISBALE_CPU "Disable installing CPU sensor" OFF)
+option (DISABLE_CPU "Disable installing CPU sensor" OFF)
+option (DISABLE_FPGA "Disable installing FPGA sensor" OFF)
 option (DISABLE_EXIT_AIR "Disable installing Exit Air Temp sensor" OFF)
 option (DISABLE_FAN "Disable installing fan sensor" OFF)
 option (DISABLE_HWMON_TEMP "Disable installing hwmon temp sensor" OFF)
@@ -57,6 +58,8 @@
 
 set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp)
 
+set (FPGA_SRC_FILES src/Utils.cpp src/FPGASensor.cpp)
+
 set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
 
 set (FAN_SRC_FILES src/TachSensor.cpp src/PwmSensor.cpp src/Utils.cpp
@@ -158,6 +161,11 @@
 target_link_libraries (cpusensor ${SENSOR_LINK_LIBS})
 target_link_libraries (cpusensor gpiodcxx)
 
+add_executable (fpgasensor src/FPGASensorMain.cpp ${FPGA_SRC_FILES})
+add_dependencies (fpgasensor sdbusplus-project)
+target_link_libraries (fpgasensor ${SENSOR_LINK_LIBS})
+target_link_libraries (fpgasensor i2c)
+
 add_executable (exitairtempsensor src/ExitAirTempSensor.cpp
                 ${EXIT_AIR_SRC_FILES})
 add_dependencies (exitairtempsensor sdbusplus-project)
@@ -193,6 +201,7 @@
 if (NOT YOCTO)
     add_dependencies (adcsensor ${EXTERNAL_PACKAGES})
     add_dependencies (cpusensor ${EXTERNAL_PACKAGES})
+    add_dependencies (fpgasensor ${EXTERNAL_PACKAGES})
     add_dependencies (exitairtempsensor ${EXTERNAL_PACKAGES})
     add_dependencies (fansensor ${EXTERNAL_PACKAGES})
     add_dependencies (hwmontempsensor ${EXTERNAL_PACKAGES})
@@ -219,6 +228,13 @@
                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
 endif ()
 
+if (NOT DISABLE_FPGA)
+    install (TARGETS fpgasensor DESTINATION bin)
+    install (FILES
+                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.fpgasensor.service
+                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+endif ()
+
 if (NOT DISABLE_EXIT_AIR)
     install (TARGETS exitairtempsensor DESTINATION bin)
     install (
diff -Naur a/include/FPGASensor.hpp b/include/FPGASensor.hpp
--- a/include/FPGASensor.hpp	1970-01-01 08:00:00.000000000 +0800
+++ b/include/FPGASensor.hpp	2019-08-16 17:17:27.166028701 +0800
@@ -0,0 +1,76 @@
+#pragma once
+
+#include "Utils.hpp"
+
+#include <boost/container/flat_map.hpp>
+#include <filesystem>
+#include <fstream>
+#include <gpiod.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+struct FPGAInfo
+{
+    FPGAInfo(const uint8_t& block, const uint8_t& addr,
+             const uint8_t& offset, const uint8_t& evtbit) :
+        block(block), addr(addr), offset(offset), evtbit(evtbit)
+    {
+    }
+    uint8_t block;
+    uint8_t addr;
+    uint8_t offset;
+    uint8_t evtbit;
+};
+
+struct FPGAConfig
+{
+    FPGAConfig(const uint8_t& snrnum, const uint8_t& snrtype,
+               const std::string& name, const std::vector<FPGAInfo>& fpgainfo) :
+        snrnum(snrnum), snrtype(snrtype), name(name), fpgainfo(std::move(fpgainfo))
+    {
+    }
+    uint8_t snrnum;
+    uint8_t snrtype;
+    std::string name;
+    std::vector<FPGAInfo> fpgainfo;
+
+    bool operator<(const FPGAConfig& rhs) const
+    {
+        return (name < rhs.name);
+    }
+};
+
+class FPGASensor
+{
+  public:
+    FPGASensor(boost::asio::io_service& io,
+               std::shared_ptr<sdbusplus::asio::connection>& conn,
+               FPGAConfig& sensorconfig);
+    ~FPGASensor();
+	
+    static constexpr unsigned int sensorPollMs = 1000;
+    uint8_t add_sel_event(const std::shared_ptr<sdbusplus::asio::connection>& bus, uint8_t snr_num, uint8_t snr_type,
+                          uint8_t ed1, uint8_t ed2, uint8_t ed3);
+  private:
+    boost::asio::deadline_timer waitTimer;
+    std::shared_ptr<sdbusplus::asio::connection> mDbusConn;
+    bool mAssert = false;
+    FPGAConfig mSnrConfig;
+
+    void setupRead(void);
+    void handleResponse(void);
+};
+
+extern boost::container::flat_map<std::string, std::unique_ptr<FPGASensor>>
+    gFpgaSensors;
+	
+constexpr auto fpgaService = "org.openbmc.control.fpga";
+constexpr auto fpgaRoot = "/org/openbmc/control/fpga";
+constexpr auto fpgaInterface = "org.openbmc.control.fpga";
+constexpr auto InventoryService = "xyz.openbmc_project.Inventory.Manager";
+constexpr auto InventoryPath = "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+constexpr auto InventoryItemIntf = "xyz.openbmc_project.Inventory.Item";
+constexpr auto PROP_INTF = "org.freedesktop.DBus.Properties";
+constexpr auto IPMIService = "xyz.openbmc_project.Ipmi.Host";
+constexpr auto IPMIPath = "/xyz/openbmc_project/Ipmi";
+constexpr auto IPMIIntf = "xyz.openbmc_project.Ipmi.Server";
diff -Naur a/include/Utils.hpp b/include/Utils.hpp
--- a/include/Utils.hpp	2019-08-07 12:49:27.458617470 +0800
+++ b/include/Utils.hpp	2019-08-08 15:10:23.166422696 +0800
@@ -16,6 +16,8 @@
 
 constexpr const char* cpuInventoryPath =
     "/xyz/openbmc_project/inventory/system/chassis/motherboard";
+constexpr const char* discretePath =
+    "/xyz/openbmc_project/inventory/system/chassis/motherboard";
 const std::regex illegalDbusRegex("[^A-Za-z0-9_]");
 
 using BasicVariantType =
diff -Naur a/service_files/xyz.openbmc_project.fpgasensor.service b/service_files/xyz.openbmc_project.fpgasensor.service
--- a/service_files/xyz.openbmc_project.fpgasensor.service	1970-01-01 08:00:00.000000000 +0800
+++ b/service_files/xyz.openbmc_project.fpgasensor.service	2019-08-12 17:28:59.374707181 +0800
@@ -0,0 +1,13 @@
+[Unit]
+Description=FPGA Sensor
+StopWhenUnneeded=false
+After=logrotate.service
+
+[Service]
+Restart=always
+RestartSec=5
+StartLimitBurst=10
+ExecStart=/usr/bin/fpgasensor
+
+[Install]
+WantedBy=multi-user.target
diff -Naur a/src/FPGASensor.cpp b/src/FPGASensor.cpp
--- a/src/FPGASensor.cpp	1970-01-01 08:00:00.000000000 +0800
+++ b/src/FPGASensor.cpp	2019-08-22 11:31:59.346009535 +0800
@@ -0,0 +1,188 @@
+/*
+// Copyright (c) 2018 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <unistd.h>
+
+#include <FPGASensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+
+static constexpr bool DEBUG = false;
+
+FPGASensor::FPGASensor(boost::asio::io_service& io,
+                       std::shared_ptr<sdbusplus::asio::connection>& conn,
+                       FPGAConfig& sensorconfig) :
+    waitTimer(io), mDbusConn(conn), mSnrConfig(sensorconfig)
+{
+    setupRead();
+}
+
+FPGASensor::~FPGASensor()
+{
+    waitTimer.cancel();
+}
+
+void FPGASensor::setupRead(void)
+{
+    if (DEBUG)
+    {
+        std::cerr << "enter FPGASensor::setupRead " << "\n";
+        std::cerr << "sensor name: " << mSnrConfig.name << "\n" << "sensor num: " << mSnrConfig.snrnum << "\n"
+                  << "sensor type: " << mSnrConfig.snrtype << "\n";
+    }
+
+    for (auto& fpgainfo : mSnrConfig.fpgainfo) 
+    {
+        uint8_t block = fpgainfo.block;
+        uint8_t addr = fpgainfo.addr;
+        uint8_t offset = fpgainfo.offset;
+        uint8_t evtbit = fpgainfo.evtbit;
+
+        // Make sure FPGA dbus is ready
+        uint8_t res_data = 0xFF;
+        auto method = mDbusConn->new_method_call(fpgaService, fpgaRoot,
+                                                 fpgaInterface, "read_fpga");
+        method.append(fpgainfo.block, fpgainfo.addr);
+        try
+        {
+            auto pid = mDbusConn->call(method);
+            if (pid.is_method_error())
+            {
+                std::cerr << "Error in method call\n";
+            }
+
+            pid.read(res_data);
+        }
+        catch (const sdbusplus::exception::SdBusError& e)
+        {
+            std::cerr << "fpga dbus error" << "\n";
+            waitTimer.cancel();
+        }
+    }
+    handleResponse();
+}
+
+void FPGASensor::handleResponse()
+{
+    size_t pollTime = FPGASensor::sensorPollMs;
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(pollTime));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        // case of timer expired
+        if (!ec)
+        {
+            for (auto& fpgainfo : mSnrConfig.fpgainfo)
+            {
+                uint8_t block = fpgainfo.block;
+                uint8_t addr = fpgainfo.addr;
+                uint8_t offset = fpgainfo.offset;
+                uint8_t evtbit = fpgainfo.evtbit;
+
+                uint8_t res_data = 0xFF;
+                auto method = mDbusConn->new_method_call(fpgaService, fpgaRoot,
+                                                         fpgaInterface, "read_fpga");
+                uint8_t event = 0xFF;
+
+                method.append(fpgainfo.block, fpgainfo.addr);
+                try
+                {
+                    auto pid = mDbusConn->call(method);
+                    if (pid.is_method_error())
+                    {
+                        std::cerr << "Error in method call\n";
+                    }
+
+                    pid.read(res_data);
+                }
+                catch (const sdbusplus::exception::SdBusError& e)
+                {
+                    std::cerr << "fpga dbus error" << "\n";
+                }
+
+                event = (res_data >> fpgainfo.offset) & 0x01;
+
+                // Assert
+                if (!mAssert && (1 == event))
+                {
+                    // TODO: Set Property True
+                    // TODO: Add SEL
+                    //auto ret = add_sel_event(mDbusConn, );
+                    mAssert = true;
+                }
+
+                // Deassert
+                if (mAssert && (0 == event))
+                {
+                    // TODO: Set Property False
+                    mAssert = false;
+                }
+            }
+            // trigger next polling
+            handleResponse();
+        }
+        // case of being canceled
+        else if (ec == boost::asio::error::operation_aborted)
+        {
+            std::cerr << "Timer of intrusion sensor is cancelled. Return \n";
+            return;
+        }
+    });
+}
+
+uint8_t FPGASensor::add_sel_event(const std::shared_ptr<sdbusplus::asio::connection>& bus, uint8_t snr_num, uint8_t snr_type,
+                                  uint8_t ed1, uint8_t ed2, uint8_t ed3)
+{
+    uint8_t netFn = 0x0A; // Storage
+    uint8_t lun = 0x00;
+    uint8_t cmd = 0x44; // Add SEL Entry command
+    std::vector<uint8_t> data = { 0x00, 0x00,             // Record ID
+                                  0x03,                   // Record Type
+                                  0x00, 0x00, 0x00, 0x00, // Time Stamp
+                                  0x20, 0x00,             // Generator ID
+                                  0x04,                   // EvM Rev
+                                  snr_type,               // Sensor Type
+                                  snr_num,                // Sensor #
+                                  0x6F,                   // Event Dir | Event Type
+                                  ed1,                    // Event Data 1
+                                  ed2,                    // Event Data 2
+                                  ed3};                   // Event Data 3
+    std::map<std::string, sdbusplus::message::variant<int>> options;
+    try
+    {
+        auto add_sel = bus->new_method_call(IPMIService, IPMIPath, IPMIIntf, "execute");
+        add_sel.append(netFn, lun, cmd, data, options);
+        auto reply = bus->call(add_sel);
+
+        if (reply.is_method_error())
+        {
+            std::cerr << "Failed to add sel by method error\n";
+            return 1;
+        }
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        std::cerr << "Failed to add sel %s\n" << e.what();
+        return 1;
+    }
+
+    return 0;
+}
diff -Naur a/src/FPGASensorMain.cpp b/src/FPGASensorMain.cpp
--- a/src/FPGASensorMain.cpp	1970-01-01 08:00:00.000000000 +0800
+++ b/src/FPGASensorMain.cpp	2019-08-22 11:24:46.945693690 +0800
@@ -0,0 +1,267 @@
+/*
+// Copyright (c) 2018 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+/      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <fcntl.h>
+
+#include <FPGASensor.hpp>
+#include <Utils.hpp>
+#include <VariantVisitors.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/process/child.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <boost/asio.hpp>
+#include <chrono>
+#include <ctime>
+#include <iostream>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <sdbusplus/asio/sd_event.hpp>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/exception.hpp>
+#include <sdbusplus/server.hpp>
+#include <sdbusplus/timer.hpp>
+
+static constexpr bool DEBUG = true;
+
+boost::container::flat_map<std::string, std::unique_ptr<FPGASensor>> gFpgaSensors;
+
+namespace fs = std::filesystem;
+
+static constexpr const char* configPrefix =
+    "xyz.openbmc_project.Configuration.";
+static constexpr std::array<const char*, 1> sensorTypes = {"Fpga"};
+static constexpr const char* sensorType =
+    "xyz.openbmc_project.Configuration.FPGASensor";
+
+bool getFpgaConfig(
+    const std::shared_ptr<sdbusplus::asio::connection>& systemBus,
+    boost::container::flat_set<FPGAConfig>& fpgaConfigs,
+    ManagedObjectType& sensorConfigs,
+    sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<
+        std::string, std::shared_ptr<sdbusplus::asio::dbus_interface>>&
+        sensorIfaces)
+{
+    bool useCache = false;
+    sensorConfigs.clear();
+
+    // use new data the first time, then refresh
+    for (const char* type : sensorTypes)
+    {
+        if (!getSensorConfiguration(configPrefix + std::string(type), systemBus,
+                                    sensorConfigs, useCache))
+        {
+            return false;
+        }
+
+        useCache = true;
+    }
+
+    // check PECI client addresses and names from FPGA configuration
+    // before starting ping operation
+    for (const char* type : sensorTypes)
+    {
+        for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigs)
+        {
+            for (const SensorBaseConfiguration& config : sensor.second)
+            {
+                if ((configPrefix + std::string(type)) != config.first)
+                {
+                    continue;
+                }
+
+                auto findName = config.second.find("Name");
+                if (findName == config.second.end())
+                {
+                    continue;
+                }
+                std::string nameRaw =
+                    std::visit(VariantToStringVisitor(), findName->second);
+                std::string name =
+                    std::regex_replace(nameRaw, illegalDbusRegex, "_");
+
+                auto findSnrNum = config.second.find("SnrNum");
+                if (findSnrNum == config.second.end())
+                {
+                    std::cerr << "Can't find 'SnrNum' setting in " << name << "\n";
+                    continue;
+                }
+                uint64_t snrnum = std::visit(VariantToUnsignedIntVisitor(), 
+				                             findSnrNum->second);
+
+                auto findSnrType = config.second.find("SnrType");
+                if (findSnrType == config.second.end())
+                {
+                    std::cerr << "Can't find 'SnrType' setting in " << name
+                              << "\n";
+                    continue;
+                }
+                uint64_t snrtype = std::visit(VariantToUnsignedIntVisitor(),
+                                              findSnrType->second);
+
+                std::vector<FPGAInfo> fpgainfoVector;
+                uint64_t FpgaBlock = 0;
+                uint64_t FpgaAddr = 0;
+                uint64_t FpgaBit = 0;
+                uint64_t EvtBit = 0;
+                uint8_t idx = 0;
+                for (const SensorBaseConfiguration& suppConfig : sensor.second)
+                {
+                    if (suppConfig.first.find("Offset") !=
+                        std::string::npos)
+                    {
+                        auto fpgaSetting = suppConfig.second;
+
+                        auto findFpgaBlock = fpgaSetting.find("Block");
+                        auto findFpgaAddr = fpgaSetting.find("Addr");
+                        auto findFpgaBit = fpgaSetting.find("Bit");
+                        auto findEvtBit = fpgaSetting.find("EvtBit");
+
+                        if (findFpgaBlock == fpgaSetting.end() ||
+                            findFpgaAddr == fpgaSetting.end() ||
+                            findFpgaBit == fpgaSetting.end() ||
+                            findEvtBit == fpgaSetting.end())
+                        {
+                            std::cerr << "Incorrect FPGA configuration setting\n";
+                            break;
+                        }
+
+                        FpgaBlock = std::visit(VariantToUnsignedIntVisitor(),
+                                               findFpgaBlock->second);
+                        FpgaBit = std::visit(VariantToUnsignedIntVisitor(),
+                                             findFpgaBit->second);
+                        FpgaAddr = std::visit(VariantToUnsignedIntVisitor(),
+                                              findFpgaAddr->second);
+                        EvtBit = std::visit(VariantToUnsignedIntVisitor(),
+                                            findEvtBit->second);
+
+                        std::cerr << "snrnum: " << snrnum << "\n";
+                        std::cerr << "snrtype: " << snrtype << "\n";
+                        std::cerr << "name: " << name << "\n";
+                        std::cerr << "block: " << FpgaBlock << "\n";
+                        std::cerr << "addr: " << FpgaAddr << "\n";
+                        std::cerr << "offset: " << FpgaBit << "\n";
+                        std::cerr << "evtbit: " << EvtBit << "\n";
+                        std::cerr << "type: " << type << "\n";
+
+                        fpgainfoVector.emplace_back((uint8_t) FpgaBlock, (uint8_t) FpgaAddr, (uint8_t) FpgaBit, (uint8_t) EvtBit);
+                        idx++;
+                    }
+                }
+
+                if (sensorIfaces.find(name) == sensorIfaces.end())
+                {
+                    auto iface = objectServer.add_interface(
+                                 "/xyz/openbmc_project/FPGASensor" + std::string("/") + name,
+                                 "xyz.openbmc_project.Sensor.Discrete.SpecificOffset");
+
+                    for (auto& fpgaEvt : fpgainfoVector)
+                    {
+                        const auto offset_property = "Offset_" + std::to_string(fpgaEvt.evtbit);
+                        iface->register_property(offset_property, false,
+                                                 sdbusplus::asio::PropertyPermission::readWrite);
+                    }
+                    iface->initialize();
+                    iface = objectServer.add_interface(
+                            "/xyz/openbmc_project/FPGASensor" + std::string("/") + name,
+                            "xyz.openbmc_project.Sensor.Discrete.SensorInfo");
+                    iface->register_property("SensorNum", snrnum);
+                    iface->register_property("SensorType", snrtype);
+                    iface->initialize();
+                    sensorIfaces[name] = std::move(iface);
+                }
+
+                fpgaConfigs.emplace(snrnum, snrtype, name, fpgainfoVector);
+            }
+        }
+    }
+
+    if (fpgaConfigs.size())
+    {
+        std::cerr << "FPGA config" << (fpgaConfigs.size() == 1 ? " is" : "s are")
+                  << " parsed\n";
+        std::cerr << "FPGA config size is " << fpgaConfigs.size() << "\n";
+        return true;
+    }
+
+    std::cerr << "fpgaConfigs is NULL\n";
+    return false;
+}
+
+void detectFPGASensor(boost::asio::io_service& io,
+                      std::shared_ptr<sdbusplus::asio::connection>& systemBus,
+                      boost::container::flat_set<FPGAConfig>& fpgaConfigs)
+{
+    for (auto& fpgasensor : fpgaConfigs)
+    {
+        gFpgaSensors[fpgasensor.name] = std::make_unique<FPGASensor>(io, systemBus, fpgasensor);
+    }
+}
+
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    boost::container::flat_set<FPGAConfig> fpgaConfigs;
+
+    systemBus->request_name("xyz.openbmc_project.FPGASensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    boost::asio::deadline_timer pingTimer(io);
+    boost::asio::deadline_timer creationTimer(io);
+    boost::asio::deadline_timer filterTimer(io);
+    ManagedObjectType sensorConfigs;
+    boost::container::flat_map<std::string,
+                               std::shared_ptr<sdbusplus::asio::dbus_interface>>
+        sensorIfaces;
+
+    if (getFpgaConfig(systemBus, fpgaConfigs, sensorConfigs, objectServer,
+                      sensorIfaces))
+    {
+        detectFPGASensor(io, systemBus, fpgaConfigs);
+    }
+    // callback to handle configuration change
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+
+            std::cout << "rescan due to configuration change \n";
+            if (getFpgaConfig(systemBus, fpgaConfigs, sensorConfigs, objectServer,
+                              sensorIfaces))
+            {
+                detectFPGASensor(io, systemBus, fpgaConfigs);
+            }
+        };
+
+    auto match = std::make_unique<sdbusplus::bus::match::match>(
+        static_cast<sdbusplus::bus::bus&>(*systemBus),
+        "type='signal',member='PropertiesChanged',path_namespace='" +
+            std::string(inventoryPath) + "',arg0namespace='" + sensorType + "'",
+        eventHandler);
+    io.run();
+    return 0;
+}
+
